created: 20230205000628716
modified: 20230424120027041
tags: detached-head
title: Git Detached Head What This Means and How to Recover
type: text/vnd.tiddlywiki

[[link|https://www.cloudbees.com/blog/git-detached-head]]

!"Git detached head" is a weird error message to receive...

//The following is a guest blog post written by Carlos Shults.//

Newcomers to Git often get confused with some of the messages that the VCS tool throws at them.  The "You are in `detached HEAD` state" one is certainly one of the weirdest.  After coming across this message, most people start furiously Googling `"git detached HEAD"`, `"git detached HEAD fix"`, or similar terms, looking for anything that might be of help.  If that's your case, you've come to the right place.

Here's the first thing you should know: //you haven't done anything wrong//.  Your repo isn't broken or anything like that.  The expression `"Detached HEAD"` might sound somewhat bizarre, but it's a perfectly valid repository state in Git.  Sure it's not the //normal// state, which would be - you've guessed it! - when HEAD is attached.  The second thing you need to know is that going back to normal is super easy.  If you just want to do that and get on with your day, go to the "How Do I Fix a Detached Head in Git?" section of this post to see how it's done.

But if you want to know more - and I guess you do - stick around and we'll help you.  What does HEAD mean in Git?  What does it mean for it to be attached or detached?  These are the kind of questions we'll answer in this post.  By the end of it, you'll have a better understanding of Git's fundamentals, and detached HEADs will never trouble you again.

!Git Detached HEAD: Reproducing the problem.

Let's start with a quick demo showing how to reach the detached HEAD state.  We'll create a repository and ad some commits to it:

```bash
mkdir git-head-demo
cd git-head-demo
git init
touch file.txt
git add .
git commit -m "Create file"
echo "Hello World!" > file.txt
git commit -a -m "Add line to the file"
echo "Second file" > file2.txt
git add .
git commit -m "Create second file"
```

With the commands above, we've created a new folder with a new repository inside it.  Then we created a new empty file and committed that with the message `"Create File"`.  Next, we added a line to that file and committed the change, with the message "Add a line to the file".  Finally, we've created another file with one line of text and committed that as well.  If you use the `git log --oneline` command, you'll see something like this:

```
$ git log --oneline
423c584 (HEAD -> master) Create second file
87ec91d Add a line to the file
3d11eb0 Create file
```

Let's say that, for testing purposes, we need to see how things were at the time of the second commit.  How would we do that?  As it turns out, we can check out a commit the same way we'd check out branches.  Remember, branches are just names for commits.  So, based on the example output above, we'd run `git checkout 87ec91d`.  Keep in mind that if you're following along by executing these commands on your own system, the hash for your commits will be different from those in the example.  Use the log command to find it.

After running the command, we get the `"You are in `detached HEAD` state [...]"` message.  Before we go on, make sure you keep this in mind: __you get to the detached HEAD state by checking out a commit directly.__

!What Is a HEAD in Git?

What does HEAD mean in Git?  To understand that, we have to take a step back and talk fundamentals.

A Git repository is a collection of objects and references.  Objects have relationships with each other, and references point to objects and to other references.  The main objects in a Git repository are commits, but other objects include blobs and trees.  The most important references in Git are branches which you can think of as labels you put on a commit.

HEAD is another important type of reference.  The purpose of HEAD is to keep track of the current point in a Git repo.  In other words, HEAD answers the question, "Where am I right now?"

For instance, when you use the `log` command, how does Git know which commit it should start displaying results from?  HEAD provides the answer.  When you create a new commit, its parent is indicated by where HEAD currently points to.

!Are you in 'Detached HEAD' State?

You've just seen that HEAD in Git is only the name of a reference that indicates the current point in a repository.  So, what does it mean for it to be attached or detached?

Most of the time, HEAD points to a branch name.  When you add a new commit, your branch reference is updated to point to it, but HEAD remains the same.  When you change branches, HEAD is updated to point to the branch you've switched to.  All of that means that, in these scenarios, HEAD is synonymous with "the last commit in the current branch".  This is the normal state, in which HEAD is //attached// to a branch.

---

A visual representation of our demo repository would look like this:

{{fix_detached_head1.png}}

As you can see, HEAD points to the controller branch, which points to the last commit.  Everything looks perfect.   

---

After running `git checkout 87ec91d`, the repo looks like this:

{{fix_detached_head2.png}}

This is the detached HEAD state; HEAD is pointing directly to a commit instead of a branch.

---

!Benefits of a Git Detached HEAD

Are there good reasons for you to be in the detached HEAD state?  You bet there are!

As you've seen, you detach the HEAD by checking out a commit.  That's already useful by itself since it allows you to go to a previous point in the project's history.  Let's say you want to check if a given bug already existed last Tuesday.  You can use the `log` command, filtering by date, to start the relevant commit hash.  Then you can check out the commit and test the application, either by hand or by running your automated test suite.

What if you could not only take a look at the past, but also change it?  That's what a detached HEAD allows you to do.  Let's review how the detached message starts:

```
You are in 'detached HEAD' state.  You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by switching to a branch.
```

In this state, you can make experimental changes, effectively creating an alternate history.  So, let's create some additional commits in the detached HEAD state and see how our report looks afterward:

```
echo "Welcome to the alternate timeline, Morty!" > ./new-file.txt
git add .
git commit -m "Create new file"
echo "Another line" >> ./newfile.txt
git commit -a -m "Add new line to the file"
```

We now have two additional commits that descend from our second commit.

Let's run `git log --online` and see the result:

```
$ git log --online
c8f4f8e (HEAD) Add a new line to the file
ec0118f Add a line to the file
3d11eb0 Create file
```

This is what the diagram looks like now:

{{fix_detached_head3.png}}

What should you do if you want to keep those changes?  And what should you do if you want to discard them?  That's what we'll see next.

!How Do I Fix a Detached HEAD in Git?

You can't fix what isn't broken.  As I've said before, a detached HEAD is a valid state in Git.  It's not a problem.  But you may still want to know how to get back to normal, and that depends on why you're in this situation in the first place.



[[How do I fix Detactched Head - Git Detached Head What This Means and How to Recover]]