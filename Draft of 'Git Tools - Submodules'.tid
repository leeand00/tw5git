created: 20200514190940982
creator: aleer
draft.of: Git Tools - Submodules
draft.title: Git Tools - Submodules
modified: 20221029004446840
modifier: aleer
tags: documentation
title: Draft of 'Git Tools - Submodules'
type: text/vnd.tiddlywiki

[[link|https://git-scm.com/book/en/v2/Git-Tools-Submodules]]

>''NOTE:'' I started reading this because I determined that this would be important for correctly storing my .dotfiles checkout for multiple projects that might have related settings; or for something like fwknopd where there is a server configuration and a client configuration, but the two go together and would need to be checked out in the same change sets for each when they were both in that state in order to work correctly.

!Git Tools - Submodules

It often happens that while working on one project, you need to use another project from within it.  Perhaps it's a library that a third party developed or that you're developing separately and using in multiple parent projects.  A common issue arises in these scenarios:

*You want to be able to treat two projects as separate, yet still be able to use one from within the other.

''Example:''

Here's an example.   Suppose you're developing a website and creating Atom feeds.  Instead of writing your own Atom-generating code, you decide to use a library.  You're likely to have to either include this code from a shared library like a CPAN install or Ruby gem, or copy the source code into your own project tree.  The issue with including the library is that it's difficult to customize the library in any way and often more difficult to deploy it, because you need to make sure every client has the library available.  The issue with copying the code into your own project is that any custom changes you make are difficult to merge when upstream changes become available.

Git addresses this issue using submodules.  Submodules allow you to keep a git repository as a sub-directory of another git repository.  This lets you clone another repository into your project and keep your commits separate.

''Starting with Submodules''

We'll walk through developing a simple project that has been split up into a main project and a few sub-projects.

Let's start by adding an existing git repository as a submodule of the repository that we're working on.  To add a new submodule you use the `git submodule add` command with the absolute or relative URL of the project you would like to start tracking.  

Let's start by adding an existing git repository as a submodule of the repository that we're working on. 

To add a new submodule you use the `git submodule add`  command with the absolute or relative URL of the projet you would like to start tracking.  In this example, we'll add a library called "DbConnector".

```
$ git submodule add http://github.com/chconic/DbConnector
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects (100%) (11/11), done.
Checking connectivity... done.
```

By default, submodules will add the subproject into a directory named the same as the repository, in this case `DbConnector`.  You can add a different path at the end of the command if you want it to go elsewhere.

---

If you run `git status` at this point, you'll notice a few things.

```
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes to be committed:
   (use "git reset HEAD <file>..." to unstage)

         new file: .gitmodules
         new file: DbConnector
```

*First you should notice the new `.gitmodules` file.  This is a configuration file that stores the mapping between the project's URL and the local subdirectory you've pulled into it into:

```
[submodule "DbConnector"]
             path = DbConnector
             url = https://github.com/chaconinc/DbConnector
```

If you have multiple submodules, you'll have multiple entries in this file.  It's important to note that this file is version-controlled with your other files, like your `.gitignore` file.  It's pushed and pulled with the rest of your project.  This is how other people who clone this project knw where to get the submodule projects from.  

>''NOTE:'' Since the URL in the `.gitmodules` file is what other people will first try to clone/fetch from, make sure to use a URL that they can access if possible.  For example, if you use a different URL to push to than others would to pull from, use the one that others have access to.  You can overwrite this value locally with `git config submodule.DbConnector.url PRIVATE_URL`  for your own use.  When applicable, a relative URL can be helpful.

The other listing in the `git status` output is the project folder entry.  If you run `git diff` on that, you see something interesting:

```
$ git diff --cached DbConnector
diff --git a/DbConnector b/DbConnector
new file mode 160000
index 0000000..c3f01dc
--- /dev/null
+++ b/DbConnector
@@ -0,0 +1 @@
+Subproject commit c3f01dc8862123d317dd46284b05b6892c7...
```

Although `DbConnector` is a subdirectory in your working directory, Git see it as a submodule and doesn't track its contents when you're not in that directory.  Instead, Git sees it as a particular commit from that repository.

If you want a nicer diff output, you can pass the `--submodule` option to `git diff`.

```
$ gif diff --cached --submodule
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000..71fc376
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "DbConnector"]
+       path = DbConnector
+       url = https://github.com/chaconic/DbConnector
Submodule DbConnector 0000000...c3f01dc (new submodule)
```

When you commit, you see something like this:

```
$ git commit -am 'Add DbConnector module'
[master fb9093c] Add DbConnector module
 2 files changed, 4 insertions(+)
 create mode 100644 .gitmodules
 create mode 160000
```

Notice that 160000 mode for the DbConnector entry.   That is a special mode in Git that basically means you're recording a commit as a directory entry rather than a subdirectory or a file.

Lastly, push these changes:

```
$ git push origin master.
```

---

!!Cloning a Project with Submodules

Here we'll clone a project with a submodule in it.  When you clone such a project, by default you get the directories that contain submodules, but none of the files within them yet:

```bash
$ git clone https://github.com/chaconic/MainProject
Cloning into 'MainProject'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
$ cd MainProject
$ ls -la
total 16
...files...
$ cd DbConnector/
$ ls 
$ 
```

The `DbConnector` directory is there, but empty.  

---

You must run two commands:

#`git submodule init` to initialize your local configuration file
#`git submodule update` to fetch all the data from that project and check out the appropriate commit listed in your superproject:

```
$ git submodule init
Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'
$ git submodule update
Cloning into 'DbConnector' ...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'
```

If you already cloned the project and forgot --recurse-submodules, you can combine the `git submodule init` and `git submodule update` steps by running `git submodule update --init`.  To also initialize, fetch and checkout any nested submodules, you can use the foolproof `git submodule update --init --recursive`

---

!!Working on a Project with Submodules

Now we have a copy of the project with submodules in it and will collaborate with our teammates on both the main project and the submodule project.

!!!Pulling in Upstream Changes from the Submodule Remote

The simplest model of using submodules in a project would be if you were simply consuming a subproject and wanted to get updates from it from time to time but were not actually modifying anything in your checkout.  Let's walk through a simple example there.

If you want to check for new work in a submodule, you can go into the directory and run `git fetch` and `git merge` the upstream branch with the local code.

```
$ git fetch
From https://github.com/chanonic/DbConnector
 c3f01dc..d0354fc  master     -> origin/master
$ git merge origin/master
Updating c3f01dc..d0354fc
Fast-foward
 scripts/connect.sh | 1 +
 src/db.c           | 1 +
 2 files changed, 2 insertions(+)
```

Now if you go back into the main project and run `git diff --submodule` you can see that the submodule was updated and get a list of commits that were added to it. If you don't want to type `--submodule` every time you run `git diff`, you can set it as the default format by setting the `diff.submodule` config value to `log`.

```
$ git config 
```

